name: Build and Deploy to ECS

on:
  workflow_dispatch:
    inputs:
      team_name:
        description: 'Team name (e.g., expo-1st, heros, rollingstars)'
        required: true
        type: string
      github_repo_name:
        description: 'Repository/Service name (e.g., test-api, test-frontend, api, frontend)'
        required: true
        type: string
  push:
    branches:
      - main
      - develop

env:
  AWS_REGION: ap-southeast-1
  # These will be set dynamically based on inputs
  TEAM_NAME: ${{ github.event.inputs.team_name || 'expo-1st' }}
  REPO_NAME: ${{ github.event.inputs.github_repo_name || 'test-api' }}

jobs:
  build-and-deploy:
    name: Build & Deploy ${{ github.event.inputs.github_repo_name }} for ${{ github.event.inputs.team_name }}
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
            docker login --username AWS --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com
          echo "registry=${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com" >> $GITHUB_OUTPUT

      - name: Set ECR repository name
        id: ecr-repo
        run: |
          # ECR repository format: hackathon-{team_name}-{repo_name}
          # This ensures each service has its own ECR repository
          ECR_REPO="hackathon-${{ env.TEAM_NAME }}-${{ env.REPO_NAME }}"
          echo "repository=$ECR_REPO" >> $GITHUB_OUTPUT
          echo "::notice::ECR Repository: $ECR_REPO"

      - name: Ensure ECR Repository Exists
        run: |
          ECR_REPO="${{ steps.ecr-repo.outputs.repository }}"
          
          if ! aws ecr describe-repositories --repository-names $ECR_REPO --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
            echo "::notice::Creating ECR repository: $ECR_REPO"
            aws ecr create-repository \
              --repository-name $ECR_REPO \
              --image-scanning-configuration scanOnPush=true \
              --region ${{ env.AWS_REGION }}
          else
            echo "::notice::ECR repository already exists: $ECR_REPO"
          fi

      - name: Ensure CloudWatch Log Group Exists
        run: |
          LOG_GROUP="/ecs/hackathon/${{ env.TEAM_NAME }}/${{ env.REPO_NAME }}"
          
          if ! aws logs describe-log-groups --log-group-name-prefix "$LOG_GROUP" --region ${{ env.AWS_REGION }} | grep -q "$LOG_GROUP"; then
            echo "::notice::Creating log group: $LOG_GROUP"
            aws logs create-log-group --log-group-name "$LOG_GROUP" --region ${{ env.AWS_REGION }}
            aws logs put-retention-policy --log-group-name "$LOG_GROUP" --retention-in-days 7 --region ${{ env.AWS_REGION }}
          else
            echo "::notice::Log group already exists: $LOG_GROUP"
          fi

      - name: Detect build method
        id: build-method
        run: |
          if [ -f "Dockerfile.node" ]; then
            echo "method=dockerfile" >> $GITHUB_OUTPUT
            echo "file=Dockerfile.node" >> $GITHUB_OUTPUT
            echo "::notice::Found Dockerfile.node, will use docker build"
          elif [ -f "Dockerfile" ]; then
            echo "method=dockerfile" >> $GITHUB_OUTPUT
            echo "file=Dockerfile" >> $GITHUB_OUTPUT
            echo "::notice::Found Dockerfile, will use docker build"
          elif [ -f "docker-compose.yml" ] || [ -f "docker-compose.yaml" ]; then
            echo "method=compose" >> $GITHUB_OUTPUT
            echo "::notice::Found docker-compose file, will use docker compose build"
            if [ -f "docker-compose.yml" ]; then
              echo "file=docker-compose.yml" >> $GITHUB_OUTPUT
            else
              echo "file=docker-compose.yaml" >> $GITHUB_OUTPUT
            fi
          else
            echo "::error::No Dockerfile or docker-compose file found"
            exit 1
          fi

      - name: Build Docker image
        run: |
          IMAGE_TAG="${{ steps.login-ecr.outputs.registry }}/${{ steps.ecr-repo.outputs.repository }}:latest"
          IMAGE_TAG_REPO="${{ steps.login-ecr.outputs.registry }}/${{ steps.ecr-repo.outputs.repository }}:${{ env.REPO_NAME }}-latest"
          IMAGE_TAG_SHA="${{ steps.login-ecr.outputs.registry }}/${{ steps.ecr-repo.outputs.repository }}:${{ env.REPO_NAME }}-${{ github.sha }}"
          
          echo "::notice::Building Docker image..."
          echo "::notice::Build method: ${{ steps.build-method.outputs.method }}"
          echo "::notice::Build file: ${{ steps.build-method.outputs.file }}"
          echo "::notice::Image tags: $IMAGE_TAG, $IMAGE_TAG_REPO, $IMAGE_TAG_SHA"
          
          if [ "${{ steps.build-method.outputs.method }}" == "compose" ]; then
            # Build using docker compose (v2 syntax)
            echo "::notice::Building with docker compose..."
            
            # Export environment variables for docker compose
            export TEAM_NAME=${{ env.TEAM_NAME }}
            export REPO_NAME=${{ env.REPO_NAME }}
            export IMAGE_TAG=$IMAGE_TAG
            
            # Get list of services that have a build section (exclude image-only services)
            echo "::notice::Detecting buildable services from compose file..."
            BUILDABLE_SERVICES=$(docker compose -f ${{ steps.build-method.outputs.file }} config --services | while read service; do
              if docker compose -f ${{ steps.build-method.outputs.file }} config | grep -A 10 "^  $service:" | grep -q "build:"; then
                echo "$service"
              fi
            done)
            
            echo "::notice::Buildable services: $BUILDABLE_SERVICES"
            
            # Determine which service to build based on REPO_NAME
            # Map: test-api -> api, test-frontend -> frontend, api -> api, frontend -> frontend
            SERVICE_TO_BUILD=""
            if [[ "${{ env.REPO_NAME }}" == *"api"* ]]; then
              SERVICE_TO_BUILD="api"
            elif [[ "${{ env.REPO_NAME }}" == *"frontend"* ]]; then
              SERVICE_TO_BUILD="frontend"
            elif echo "$BUILDABLE_SERVICES" | grep -q "^${{ env.REPO_NAME }}$"; then
              SERVICE_TO_BUILD="${{ env.REPO_NAME }}"
            else
              # Default to first buildable service
              SERVICE_TO_BUILD=$(echo "$BUILDABLE_SERVICES" | head -n1)
            fi
            
            if [ -z "$SERVICE_TO_BUILD" ]; then
              echo "::error::No buildable service found in docker-compose file"
              exit 1
            fi
            
            echo "::notice::Building service: $SERVICE_TO_BUILD"
            docker compose -f ${{ steps.build-method.outputs.file }} build $SERVICE_TO_BUILD
            
            # Get the built image name (tag it with the compose project name + service name)
            COMPOSE_PROJECT="${PWD##*/}"
            COMPOSE_IMAGE="${COMPOSE_PROJECT}-${SERVICE_TO_BUILD}"
            
            echo "::notice::Tagging image: $COMPOSE_IMAGE"
            docker tag $COMPOSE_IMAGE $IMAGE_TAG
            docker tag $COMPOSE_IMAGE $IMAGE_TAG_REPO
            docker tag $COMPOSE_IMAGE $IMAGE_TAG_SHA
          else
            # Build using Dockerfile
            echo "::notice::Building with Dockerfile..."
            docker build \
              --platform linux/amd64 \
              -f ${{ steps.build-method.outputs.file }} \
              -t $IMAGE_TAG \
              -t $IMAGE_TAG_REPO \
              -t $IMAGE_TAG_SHA \
              --build-arg TEAM_NAME=${{ env.TEAM_NAME }} \
              --build-arg REPO_NAME=${{ env.REPO_NAME }} \
              .
          fi
          
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_ENV
          echo "image_tag_repo=$IMAGE_TAG_REPO" >> $GITHUB_ENV
          echo "image_tag_sha=$IMAGE_TAG_SHA" >> $GITHUB_ENV

      - name: Push Docker image to ECR
        run: |
          echo "::notice::Pushing images to ECR..."
          docker push ${{ env.image_tag }}
          docker push ${{ env.image_tag_repo }}
          docker push ${{ env.image_tag_sha }}
          echo "::notice::Successfully pushed all image tags"

      - name: Set ECS service details
        id: ecs-service
        run: |
          # ECS service format: hackathon-{team_name}-{repo_name}
          # This ensures each service has its own ECS service
          ECS_SERVICE="hackathon-${{ env.TEAM_NAME }}-${{ env.REPO_NAME }}"
          ECS_CLUSTER="hackathon-cluster"
          echo "service=$ECS_SERVICE" >> $GITHUB_OUTPUT
          echo "cluster=$ECS_CLUSTER" >> $GITHUB_OUTPUT
          echo "::notice::ECS Service: $ECS_SERVICE"
          echo "::notice::ECS Cluster: $ECS_CLUSTER"
          
          # Also set as env vars for the summary step
          echo "ECS_SERVICE=$ECS_SERVICE" >> $GITHUB_ENV
          echo "ECS_CLUSTER=$ECS_CLUSTER" >> $GITHUB_ENV

      - name: Check if ECS service exists
        id: check-ecs
        run: |
          if aws ecs describe-services \
            --cluster ${{ steps.ecs-service.outputs.cluster }} \
            --services ${{ steps.ecs-service.outputs.service }} \
            --region ${{ env.AWS_REGION }} \
            --query 'services[0].serviceName' \
            --output text 2>/dev/null | grep -q "${{ steps.ecs-service.outputs.service }}"; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "::notice::ECS service exists"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "::warning::ECS service does not exist, will create it"
          fi

      - name: Create ECS Task Definition and Service
        if: steps.check-ecs.outputs.exists == 'false'
        run: |
          TASK_FAMILY="hackathon-${{ env.TEAM_NAME }}-${{ env.REPO_NAME }}"
          SERVICE_NAME="${{ steps.ecs-service.outputs.service }}"
          CLUSTER_NAME="${{ steps.ecs-service.outputs.cluster }}"
          
          echo "::notice::Creating task definition: $TASK_FAMILY"
          
          # Create task definition
          cat > task-definition.json <<EOF
          {
            "family": "$TASK_FAMILY",
            "networkMode": "awsvpc",
            "requiresCompatibilities": ["FARGATE"],
            "cpu": "256",
            "memory": "512",
            "executionRoleArn": "arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/hackathon-ecs-execution-role",
            "taskRoleArn": "arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/hackathon-ecs-task-role",
            "containerDefinitions": [
              {
                "name": "${{ env.REPO_NAME }}",
                "image": "${{ env.image_tag }}",
                "portMappings": [
                  {
                    "containerPort": 3000,
                    "protocol": "tcp"
                  }
                ],
                "environment": [
                  {"name": "NODE_ENV", "value": "production"},
                  {"name": "TEAM_NAME", "value": "${{ env.TEAM_NAME }}"},
                  {"name": "REPO_NAME", "value": "${{ env.REPO_NAME }}"},
                  {"name": "PORT", "value": "3000"}
                ],
                "logConfiguration": {
                  "logDriver": "awslogs",
                  "options": {
                    "awslogs-group": "/ecs/hackathon/${{ env.TEAM_NAME }}/${{ env.REPO_NAME }}",
                    "awslogs-region": "${{ env.AWS_REGION }}",
                    "awslogs-stream-prefix": "ecs"
                  }
                },
                "healthCheck": {
                  "command": ["CMD-SHELL", "wget --no-verbose --tries=1 --spider http://localhost:3000/health || exit 1"],
                  "interval": 30,
                  "timeout": 5,
                  "retries": 3,
                  "startPeriod": 60
                }
              }
            ]
          }
          EOF
          
          # Register task definition
          TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://task-definition.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          echo "::notice::Task definition created: $TASK_DEF_ARN"
          
          # Get network configuration from template service
          echo "::notice::Getting network configuration from hackathon-expo-1st"
          NETWORK_CONFIG=$(aws ecs describe-services \
            --cluster $CLUSTER_NAME \
            --services hackathon-expo-1st \
            --region ${{ env.AWS_REGION }} \
            --query 'services[0].networkConfiguration.awsvpcConfiguration' \
            --output json)
          
          SUBNET_IDS=$(echo $NETWORK_CONFIG | jq -r '.subnets | join(",")')
          SECURITY_GROUP_ID=$(echo $NETWORK_CONFIG | jq -r '.securityGroups[0]')
          
          echo "::notice::Creating ECS service: $SERVICE_NAME"
          echo "::notice::Using subnets: $SUBNET_IDS"
          echo "::notice::Using security group: $SECURITY_GROUP_ID"
          
          # Create ECS service
          aws ecs create-service \
            --cluster $CLUSTER_NAME \
            --service-name $SERVICE_NAME \
            --task-definition $TASK_FAMILY \
            --desired-count 1 \
            --launch-type FARGATE \
            --platform-version LATEST \
            --network-configuration "awsvpcConfiguration={subnets=[$SUBNET_IDS],securityGroups=[$SECURITY_GROUP_ID],assignPublicIp=ENABLED}" \
            --enable-execute-command \
            --region ${{ env.AWS_REGION }}
          
          echo "::notice::Service created successfully!"

      - name: Force new deployment
        if: steps.check-ecs.outputs.exists == 'true'
        run: |
          echo "::notice::Forcing new deployment for ${{ steps.ecs-service.outputs.service }}..."
          aws ecs update-service \
            --cluster ${{ steps.ecs-service.outputs.cluster }} \
            --service ${{ steps.ecs-service.outputs.service }} \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}

      - name: Wait for service stability
        run: |
          echo "::notice::Waiting for service to stabilize (this may take several minutes)..."
          aws ecs wait services-stable \
            --cluster ${{ steps.ecs-service.outputs.cluster }} \
            --services ${{ steps.ecs-service.outputs.service }} \
            --region ${{ env.AWS_REGION }}
          echo "::notice::Service is stable"

      - name: Get service status
        run: |
          echo "::group::Service Status"
          aws ecs describe-services \
            --cluster ${{ steps.ecs-service.outputs.cluster }} \
            --services ${{ steps.ecs-service.outputs.service }} \
            --region ${{ env.AWS_REGION }} \
            --query 'services[0].{Status:status,DesiredCount:desiredCount,RunningCount:runningCount,PendingCount:pendingCount}' \
            --output table
          echo "::endgroup::"

      - name: Get task details
        run: |
          echo "::group::Recent Tasks"
          TASK_ARNS=$(aws ecs list-tasks \
            --cluster ${{ steps.ecs-service.outputs.cluster }} \
            --service-name ${{ steps.ecs-service.outputs.service }} \
            --region ${{ env.AWS_REGION }} \
            --query 'taskArns[0:3]' \
            --output text)
          
          if [ ! -z "$TASK_ARNS" ]; then
            aws ecs describe-tasks \
              --cluster ${{ steps.ecs-service.outputs.cluster }} \
              --tasks $TASK_ARNS \
              --region ${{ env.AWS_REGION }} \
              --query 'tasks[*].{TaskArn:taskArn,Status:lastStatus,Health:healthStatus,Started:startedAt}' \
              --output table
          else
            echo "No tasks found"
          fi
          echo "::endgroup::"

      - name: Deployment summary
        if: always()
        run: |
          echo "::group::Deployment Summary"
          echo "================================================"
          echo "Deployment Status: ${{ job.status }}"
          echo "================================================"
          echo "Team Name: ${{ env.TEAM_NAME }}"
          echo "Repository/Service: ${{ env.REPO_NAME }}"
          echo "ECR Repository: ${{ steps.ecr-repo.outputs.repository }}"
          echo "ECS Cluster: ${{ env.ECS_CLUSTER }}"
          echo "ECS Service: ${{ env.ECS_SERVICE }}"
          echo "================================================"
          echo "URLs:"
          echo "  ðŸŒ Team Base URL:    https://${{ env.TEAM_NAME }}.bp.elmhakathon.com"
          echo "  ðŸŽ¯ Service URL:      https://${{ env.REPO_NAME }}.${{ env.TEAM_NAME }}.bp.elmhakathon.com"
          echo ""
          echo "Note: Each service is accessible via its own subdomain"
          echo "      (e.g., api.expo-1st.bp.elmhakathon.com, frontend.expo-1st.bp.elmhakathon.com)"
          echo "================================================"
          echo "Image Tags:"
          echo "  - latest"
          echo "  - ${{ env.REPO_NAME }}-latest"
          echo "  - ${{ env.REPO_NAME }}-${{ github.sha }}"
          echo "================================================"
          echo "::endgroup::"
          
          if [ "${{ job.status }}" == "success" ]; then
            echo "::notice::âœ… Deployment successful for ${{ env.TEAM_NAME }}/${{ env.REPO_NAME }}"
            echo "::notice::ðŸŒ Team Base: https://${{ env.TEAM_NAME }}.bp.elmhakathon.com"
            echo "::notice::ðŸŽ¯ Service URL: https://${{ env.REPO_NAME }}.${{ env.TEAM_NAME }}.bp.elmhakathon.com"
          else
            echo "::error::âŒ Deployment failed for ${{ env.TEAM_NAME }}/${{ env.REPO_NAME }}"
          fi

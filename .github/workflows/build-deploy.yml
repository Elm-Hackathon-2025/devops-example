name: Build and Deploy to ECS

on:
  workflow_dispatch:
    inputs:
      team_name:
        description: 'Team name (e.g., expo-1st, heros, rollingstars)'
        required: true
        type: string
  push:
    branches:
      - main
      - develop

env:
  AWS_REGION: ap-southeast-1
  # Team name is set from input or defaults to expo-1st
  TEAM_NAME: ${{ github.event.inputs.team_name || 'expo-1st' }}

jobs:
  build-and-deploy:
    name: Build & Deploy All Services for ${{ github.event.inputs.team_name }}
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
            docker login --username AWS --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com
          echo "registry=${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com" >> $GITHUB_OUTPUT

      - name: Detect build method and services
        id: detect-services
        run: |
          if [ -f "docker-compose.yml" ] || [ -f "docker-compose.yaml" ]; then
            echo "method=compose" >> $GITHUB_OUTPUT
            if [ -f "docker-compose.yml" ]; then
              COMPOSE_FILE="docker-compose.yml"
            else
              COMPOSE_FILE="docker-compose.yaml"
            fi
            echo "file=$COMPOSE_FILE" >> $GITHUB_OUTPUT
            echo "::notice::Found $COMPOSE_FILE, detecting buildable services..."
            
            # Get list of services that have a build section
            BUILDABLE_SERVICES=$(docker compose -f $COMPOSE_FILE config --services | while read service; do
              if docker compose -f $COMPOSE_FILE config | grep -A 10 "^  $service:" | grep -q "build:"; then
                echo "$service"
              fi
            done)
            
            if [ -z "$BUILDABLE_SERVICES" ]; then
              echo "::error::No buildable services found in $COMPOSE_FILE"
              exit 1
            fi
            
            # Convert to JSON array for matrix strategy
            SERVICES_JSON=$(echo "$BUILDABLE_SERVICES" | jq -R -s -c 'split("\n") | map(select(length > 0))')
            echo "services=$SERVICES_JSON" >> $GITHUB_OUTPUT
            echo "::notice::Buildable services: $BUILDABLE_SERVICES"
            
          elif [ -f "Dockerfile" ] || [ -f "Dockerfile.node" ]; then
            echo "method=dockerfile" >> $GITHUB_OUTPUT
            if [ -f "Dockerfile.node" ]; then
              echo "file=Dockerfile.node" >> $GITHUB_OUTPUT
            else
              echo "file=Dockerfile" >> $GITHUB_OUTPUT
            fi
            # For Dockerfile, create a single-service array with the repo name as service name
            echo "services=[\"app\"]" >> $GITHUB_OUTPUT
            echo "::notice::Found Dockerfile, will build single service"
          else
            echo "::error::No Dockerfile or docker-compose file found"
            exit 1
          fi

      - name: Build and Push All Services
        run: |
          BUILD_METHOD="${{ steps.detect-services.outputs.method }}"
          SERVICES='${{ steps.detect-services.outputs.services }}'
          
          echo "::group::Building and Pushing Services"
          echo "Build method: $BUILD_METHOD"
          echo "Services to build: $SERVICES"
          
          # Parse services JSON array
          SERVICE_COUNT=$(echo $SERVICES | jq -r 'length')
          echo "::notice::Found $SERVICE_COUNT service(s) to build and deploy"
          
          for i in $(seq 0 $((SERVICE_COUNT - 1))); do
            COMPOSE_SERVICE_NAME=$(echo $SERVICES | jq -r ".[$i]")
            echo "::group::Processing compose service: $COMPOSE_SERVICE_NAME"
            
            # Map compose service names to deployment service names
            # By default, prefix with "test-" to match docker-compose SERVICE_NAME env vars
            case "$COMPOSE_SERVICE_NAME" in
              api)
                SERVICE_NAME="test-api"
                ;;
              frontend)
                SERVICE_NAME="test-frontend"
                ;;
              *)
                # For other services, check if there's a SERVICE_NAME env var
                SERVICE_NAME=$(docker compose -f ${{ steps.detect-services.outputs.file }} config 2>/dev/null | \
                  grep -A 30 "  $COMPOSE_SERVICE_NAME:" | \
                  grep "SERVICE_NAME" | \
                  grep -oE 'test-[a-zA-Z0-9_-]+' | \
                  head -1)
                # If not found, use compose service name as-is
                if [ -z "$SERVICE_NAME" ]; then
                  SERVICE_NAME="$COMPOSE_SERVICE_NAME"
                fi
                ;;
            esac
            
            echo "::notice::Compose service: $COMPOSE_SERVICE_NAME"
            echo "::notice::Deployment service name: $SERVICE_NAME"
            
            # ECR repository format: hackathon-{team_name}-{service_name}
            ECR_REPO="hackathon-${{ env.TEAM_NAME }}-$SERVICE_NAME"
            IMAGE_TAG="${{ steps.login-ecr.outputs.registry }}/$ECR_REPO:latest"
            IMAGE_TAG_REPO="${{ steps.login-ecr.outputs.registry }}/$ECR_REPO:$SERVICE_NAME-latest"
            IMAGE_TAG_SHA="${{ steps.login-ecr.outputs.registry }}/$ECR_REPO:$SERVICE_NAME-${{ github.sha }}"
            
            echo "::notice::ECR Repository: $ECR_REPO"
            echo "::notice::Image tags: latest, $SERVICE_NAME-latest, $SERVICE_NAME-${{ github.sha }}"
            
            # Ensure ECR Repository Exists
            if ! aws ecr describe-repositories --repository-names $ECR_REPO --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
              echo "::notice::Creating ECR repository: $ECR_REPO"
              aws ecr create-repository \
                --repository-name $ECR_REPO \
                --image-scanning-configuration scanOnPush=true \
                --region ${{ env.AWS_REGION }}
            else
              echo "::notice::ECR repository already exists: $ECR_REPO"
            fi
            
            # Ensure CloudWatch Log Group Exists
            LOG_GROUP="/ecs/hackathon/${{ env.TEAM_NAME }}/$SERVICE_NAME"
            if aws logs describe-log-groups --log-group-name-prefix "$LOG_GROUP" --region ${{ env.AWS_REGION }} --query "logGroups[?logGroupName=='$LOG_GROUP'].logGroupName" --output text | grep -q "$LOG_GROUP"; then
              echo "::notice::Log group already exists: $LOG_GROUP"
            else
              echo "::notice::Creating log group: $LOG_GROUP"
              if aws logs create-log-group --log-group-name "$LOG_GROUP" --region ${{ env.AWS_REGION }} 2>&1; then
                aws logs put-retention-policy --log-group-name "$LOG_GROUP" --retention-in-days 7 --region ${{ env.AWS_REGION }} || true
              else
                echo "::notice::Log group may already exist (race condition), continuing..."
              fi
            fi
            
            # Build based on method
            if [ "$BUILD_METHOD" == "compose" ]; then
              echo "::notice::Building with docker compose..."
              docker compose -f ${{ steps.detect-services.outputs.file }} build $COMPOSE_SERVICE_NAME
              
              # Get the built image name
              COMPOSE_PROJECT="${PWD##*/}"
              COMPOSE_IMAGE="${COMPOSE_PROJECT}-${COMPOSE_SERVICE_NAME}"
              
              echo "::notice::Tagging image: $COMPOSE_IMAGE -> $IMAGE_TAG"
              docker tag $COMPOSE_IMAGE $IMAGE_TAG
              docker tag $COMPOSE_IMAGE $IMAGE_TAG_REPO
              docker tag $COMPOSE_IMAGE $IMAGE_TAG_SHA
            else
              echo "::notice::Building with Dockerfile..."
              docker build \
                --platform linux/amd64 \
                -f ${{ steps.detect-services.outputs.file }} \
                -t $IMAGE_TAG \
                -t $IMAGE_TAG_REPO \
                -t $IMAGE_TAG_SHA \
                --build-arg TEAM_NAME=${{ env.TEAM_NAME }} \
                --build-arg SERVICE_NAME=$SERVICE_NAME \
                .
            fi
            
            # Push images
            echo "::notice::Pushing images to ECR..."
            docker push $IMAGE_TAG
            docker push $IMAGE_TAG_REPO
            docker push $IMAGE_TAG_SHA
            echo "::notice::‚úÖ Successfully pushed all tags for $SERVICE_NAME"
            
            # Store service info for deployment step
            echo "SERVICE_${i}_NAME=$SERVICE_NAME" >> $GITHUB_ENV
            echo "SERVICE_${i}_ECR_REPO=$ECR_REPO" >> $GITHUB_ENV
            echo "SERVICE_${i}_IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
            
            # Extract container port from docker-compose
            if [ "$BUILD_METHOD" == "compose" ]; then
              CONTAINER_PORT=$(docker compose -f ${{ steps.detect-services.outputs.file }} config 2>/dev/null | \
                grep -A 20 "  $COMPOSE_SERVICE_NAME:" | \
                grep -E "^\s+- \"[0-9]+:[0-9]+\"" | \
                head -1 | \
                grep -oE '[0-9]+:[0-9]+' | \
                cut -d':' -f2)
              
              # If no port found, default to 3000
              if [ -z "$CONTAINER_PORT" ]; then
                CONTAINER_PORT=3000
              fi
            else
              CONTAINER_PORT=3000
            fi
            
            echo "SERVICE_${i}_PORT=$CONTAINER_PORT" >> $GITHUB_ENV
            echo "::notice::Container port: $CONTAINER_PORT"
            
            echo "::endgroup::"
          done
          
          # Store service count for deployment
          echo "SERVICE_COUNT=$SERVICE_COUNT" >> $GITHUB_ENV
          echo "::endgroup::"

      - name: Deploy All Services to ECS
        run: |
          echo "::group::Deploying Services to ECS"
          SERVICE_COUNT=${{ env.SERVICE_COUNT }}
          CLUSTER_NAME="hackathon-cluster"
          
          # Get IAM role ARNs and network config from template service (once)
          echo "::notice::Getting IAM roles and network config from template service"
          TEMPLATE_TASK_DEF=$(aws ecs describe-services \
            --cluster $CLUSTER_NAME \
            --services hackathon-expo-1st \
            --region ${{ env.AWS_REGION }} \
            --query 'services[0].taskDefinition' \
            --output text)
          
          ROLE_ARNS=$(aws ecs describe-task-definition \
            --task-definition $TEMPLATE_TASK_DEF \
            --region ${{ env.AWS_REGION }} \
            --output json | jq -r '{executionRole: .taskDefinition.executionRoleArn, taskRole: .taskDefinition.taskRoleArn}')
          
          EXECUTION_ROLE_ARN=$(echo $ROLE_ARNS | jq -r '.executionRole')
          TASK_ROLE_ARN=$(echo $ROLE_ARNS | jq -r '.taskRole')
          
          NETWORK_CONFIG=$(aws ecs describe-services \
            --cluster $CLUSTER_NAME \
            --services hackathon-expo-1st \
            --region ${{ env.AWS_REGION }} \
            --query 'services[0].networkConfiguration.awsvpcConfiguration' \
            --output json)
          
          SUBNET_IDS=$(echo $NETWORK_CONFIG | jq -r '.subnets | join(",")')
          SECURITY_GROUP_ID=$(echo $NETWORK_CONFIG | jq -r '.securityGroups[0]')
          
          echo "::notice::Using Execution Role: $EXECUTION_ROLE_ARN"
          echo "::notice::Using Task Role: $TASK_ROLE_ARN"
          echo "::notice::Using Subnets: $SUBNET_IDS"
          echo "::notice::Using Security Group: $SECURITY_GROUP_ID"
          
          for i in $(seq 0 $((SERVICE_COUNT - 1))); do
            SERVICE_NAME=$(printenv SERVICE_${i}_NAME)
            ECR_REPO=$(printenv SERVICE_${i}_ECR_REPO)
            IMAGE_TAG=$(printenv SERVICE_${i}_IMAGE_TAG)
            CONTAINER_PORT=$(printenv SERVICE_${i}_PORT)
            
            ECS_SERVICE="hackathon-${{ env.TEAM_NAME }}-$SERVICE_NAME"
            TASK_FAMILY="hackathon-${{ env.TEAM_NAME }}-$SERVICE_NAME"
            
            echo "::group::Deploying service: $SERVICE_NAME"
            echo "::notice::ECS Service: $ECS_SERVICE"
            echo "::notice::Task Family: $TASK_FAMILY"
            echo "::notice::Image: $IMAGE_TAG"
            echo "::notice::Container Port: $CONTAINER_PORT"
            
            # Create task definition
            cat > task-definition-${i}.json <<EOF
          {
            "family": "$TASK_FAMILY",
            "networkMode": "awsvpc",
            "requiresCompatibilities": ["FARGATE"],
            "cpu": "256",
            "memory": "512",
            "executionRoleArn": "$EXECUTION_ROLE_ARN",
            "taskRoleArn": "$TASK_ROLE_ARN",
            "containerDefinitions": [
              {
                "name": "$SERVICE_NAME",
                "image": "$IMAGE_TAG",
                "portMappings": [
                  {
                    "containerPort": $CONTAINER_PORT,
                    "protocol": "tcp"
                  }
                ],
                "environment": [
                  {"name": "NODE_ENV", "value": "production"},
                  {"name": "TEAM_NAME", "value": "${{ env.TEAM_NAME }}"},
                  {"name": "SERVICE_NAME", "value": "$SERVICE_NAME"},
                  {"name": "PORT", "value": "$CONTAINER_PORT"}
                ],
                "logConfiguration": {
                  "logDriver": "awslogs",
                  "options": {
                    "awslogs-group": "/ecs/hackathon/${{ env.TEAM_NAME }}/$SERVICE_NAME",
                    "awslogs-region": "${{ env.AWS_REGION }}",
                    "awslogs-stream-prefix": "ecs"
                  }
                },
                "healthCheck": {
                  "command": ["CMD-SHELL", "wget --no-verbose --tries=1 --spider http://localhost:$CONTAINER_PORT/health || exit 1"],
                  "interval": 30,
                  "timeout": 5,
                  "retries": 3,
                  "startPeriod": 60
                }
              }
            ]
          }
          EOF
            
            # Register task definition
            TASK_DEF_ARN=$(aws ecs register-task-definition \
              --cli-input-json file://task-definition-${i}.json \
              --query 'taskDefinition.taskDefinitionArn' \
              --output text)
            
            echo "::notice::Task definition registered: $TASK_DEF_ARN"
            
            # Check if service exists
            if aws ecs describe-services \
              --cluster $CLUSTER_NAME \
              --services $ECS_SERVICE \
              --region ${{ env.AWS_REGION }} \
              --query 'services[0].serviceName' \
              --output text 2>/dev/null | grep -q "$ECS_SERVICE"; then
              
              echo "::notice::Service exists, updating with new task definition..."
              aws ecs update-service \
                --cluster $CLUSTER_NAME \
                --service $ECS_SERVICE \
                --task-definition $TASK_DEF_ARN \
                --force-new-deployment \
                --region ${{ env.AWS_REGION }}
            else
              echo "::notice::Creating new service..."
              aws ecs create-service \
                --cluster $CLUSTER_NAME \
                --service-name $ECS_SERVICE \
                --task-definition $TASK_FAMILY \
                --desired-count 1 \
                --launch-type FARGATE \
                --platform-version LATEST \
                --network-configuration "awsvpcConfiguration={subnets=[$SUBNET_IDS],securityGroups=[$SECURITY_GROUP_ID],assignPublicIp=ENABLED}" \
                --enable-execute-command \
                --region ${{ env.AWS_REGION }}
            fi
            
            echo "::endgroup::"
          done
          echo "::endgroup::"

      - name: Wait for All Services to Stabilize
        run: |
          echo "::group::Waiting for Services to Stabilize"
          SERVICE_COUNT=${{ env.SERVICE_COUNT }}
          CLUSTER_NAME="hackathon-cluster"
          
          for i in $(seq 0 $((SERVICE_COUNT - 1))); do
            SERVICE_NAME=$(printenv SERVICE_${i}_NAME)
            ECS_SERVICE="hackathon-${{ env.TEAM_NAME }}-$SERVICE_NAME"
            
            echo "::notice::Waiting for $ECS_SERVICE to stabilize..."
            echo "::notice::Checking service events for issues..."
            
            # Show service events to diagnose issues
            aws ecs describe-services \
              --cluster $CLUSTER_NAME \
              --services $ECS_SERVICE \
              --region ${{ env.AWS_REGION }} \
              --query 'services[0].events[0:5].[createdAt,message]' \
              --output table
            
            # Wait with timeout (max 10 minutes per service)
            timeout 600 aws ecs wait services-stable \
              --cluster $CLUSTER_NAME \
              --services $ECS_SERVICE \
              --region ${{ env.AWS_REGION }} || {
              echo "::error::Service $ECS_SERVICE failed to stabilize within 10 minutes"
              echo "::group::Service Details"
              aws ecs describe-services \
                --cluster $CLUSTER_NAME \
                --services $ECS_SERVICE \
                --region ${{ env.AWS_REGION }} \
                --query 'services[0]' \
                --output json
              echo "::endgroup::"
              
              echo "::group::Task Details"
              TASK_ARNS=$(aws ecs list-tasks \
                --cluster $CLUSTER_NAME \
                --service-name $ECS_SERVICE \
                --region ${{ env.AWS_REGION }} \
                --query 'taskArns' \
                --output text)
              
              if [ ! -z "$TASK_ARNS" ]; then
                aws ecs describe-tasks \
                  --cluster $CLUSTER_NAME \
                  --tasks $TASK_ARNS \
                  --region ${{ env.AWS_REGION }} \
                  --output json
              fi
              echo "::endgroup::"
              
              echo "::warning::Continuing with deployment despite timeout..."
            }
            
            echo "::notice::‚úÖ $ECS_SERVICE is stable"
          done
          echo "::endgroup::"

      - name: Get All Services Status
        run: |
          echo "::group::All Services Status"
          SERVICE_COUNT=${{ env.SERVICE_COUNT }}
          CLUSTER_NAME="hackathon-cluster"
          
          for i in $(seq 0 $((SERVICE_COUNT - 1))); do
            SERVICE_NAME=$(printenv SERVICE_${i}_NAME)
            ECS_SERVICE="hackathon-${{ env.TEAM_NAME }}-$SERVICE_NAME"
            
            echo "::group::Status: $SERVICE_NAME"
            aws ecs describe-services \
              --cluster $CLUSTER_NAME \
              --services $ECS_SERVICE \
              --region ${{ env.AWS_REGION }} \
              --query 'services[0].{Status:status,DesiredCount:desiredCount,RunningCount:runningCount,PendingCount:pendingCount}' \
              --output table
            
            TASK_ARNS=$(aws ecs list-tasks \
              --cluster $CLUSTER_NAME \
              --service-name $ECS_SERVICE \
              --region ${{ env.AWS_REGION }} \
              --query 'taskArns[0:3]' \
              --output text)
            
            if [ ! -z "$TASK_ARNS" ]; then
              aws ecs describe-tasks \
                --cluster $CLUSTER_NAME \
                --tasks $TASK_ARNS \
                --region ${{ env.AWS_REGION }} \
                --query 'tasks[*].{TaskArn:taskArn,Status:lastStatus,Health:healthStatus,Started:startedAt}' \
                --output table
            else
              echo "No tasks found"
            fi
            echo "::endgroup::"
          done
          echo "::endgroup::"

      - name: Deployment summary
        if: always()
        run: |
          echo "::group::Deployment Summary"
          echo "================================================"
          echo "Deployment Status: ${{ job.status }}"
          echo "================================================"
          echo "Team Name: ${{ env.TEAM_NAME }}"
          echo "Services Deployed: ${{ env.SERVICE_COUNT }}"
          echo "ECS Cluster: hackathon-cluster"
          echo "================================================"
          echo "Deployed Services:"
          
          SERVICE_COUNT=${{ env.SERVICE_COUNT }}
          for i in $(seq 0 $((SERVICE_COUNT - 1))); do
            SERVICE_NAME=$(printenv SERVICE_${i}_NAME)
            echo "  - $SERVICE_NAME"
            echo "    ECS Service: hackathon-${{ env.TEAM_NAME }}-$SERVICE_NAME"
            echo "    URL: https://$SERVICE_NAME.${{ env.TEAM_NAME }}.bp.elmhakathon.com"
          done
          
          echo "================================================"
          echo "Team Base URL: https://${{ env.TEAM_NAME }}.bp.elmhakathon.com"
          echo "================================================"
          echo "::endgroup::"
          
          if [ "${{ job.status }}" == "success" ]; then
            echo "::notice::‚úÖ Deployment successful for team ${{ env.TEAM_NAME }}"
            echo "::notice::üåê Team Base: https://${{ env.TEAM_NAME }}.bp.elmhakathon.com"
          else
            echo "::error::‚ùå Deployment failed for team ${{ env.TEAM_NAME }}"
          fi
